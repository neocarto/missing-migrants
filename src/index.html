<!doctype html>

<notebook theme="glacier">
  <title>Missing Migrants</title>

  <script type="text/markdown">
    # Mourir aux portes de l'Europe</ins>

    ## Mise √† jour de la carte de Migreurop

    <small>Document r√©alis√© par [Nicolas Lambert](https://neocarto.github.io/cv/) avec Observable Notebooks 2.0<br/>[CNRS](https://www.cnrs.fr/fr) / [UAR RIATE](https://riate.cnrs.fr/) - Centre pour l'analyse spatiale et la g√©ovisualisation<br/><br/>Les cartes de sont g√©n√©r√©es automatiquement √† l'aide de la biblioth√®que JavaScript [**`geoviz`**](https://github.com/riatelab/geoviz).<br/>Dei√®re mise √† jour : <b>${formatDateFR(date)}</b></small><hr/>
  </script>

  <script type="text/markdown">
    <small>_¬´ Il ne faut pas essayer de fixer l'Homme, puisque son destin est d'√™tre l√¢ch√© ¬ª<br/>Frantz Fanon, 1952_</small>

    <hr/>
  </script>

  <script type="text/markdown">
    <b>Entre le 1er janvier 1993 et ${formatDateFR(date)}, <ins>${d3

    .format(",.2r")(d3.sum(data.map((d) => d.nb)))
    .replace(",", " ")} personnes</ins> sont mortes en migration en tentant de rejoindre l'Europe</b>. Noyades, asphyxies, accidents, √©crasements, empoisonnements, explosions sur des champs de mines, morts de faim, de soif, d‚Äô√©puisement, absence de soins m√©dicaux, violences polici√®res, etc. autant de trag√©dies humaines qui auraient pu √™tre √©vit√©es.
  </script>

  <script type="text/markdown">
    ## <ins>Les donn√©es</ins>
  </script>

  <script type="text/markdown">
    Les donn√©es utilis√©es ici sont issues de 3 sources de donn√©es. Les donn√©es de 1993 √† 1999 sont issues de l'association **[UNITED](https://unitedfia.org/)** for Intercultural Action, une organisation europ√©enne de solidarit√© avec les migrants. Les donn√©es de 2000 √† 2013 sont issues du projet de data journalisme " **[The Migrants Files](https://www.themigrantsfiles.com/)**", une initiative journalistique qui a collect√© des donn√©es sur les morts de migrants √† travers le monde. Enfin, les donn√©es de 2014 √† aujourd'hui sont issues de l'Organisation Internationale pour les Migrations (**[OIM](https://missingmigrants.iom.int/)**), qui collecte des donn√©es sur les morts de migrants √† travers le monde.

    ‚ö†Ô∏è _Il s'agit donc d'une compliation de 3 bases de donn√©es diff√©rentes r√©alis√©es selon des m√©thodologies et des objectifs diff√©rents. Ce qui n'est pas sans poser quelques biais (d√©finitions, effets de sonde, comparabilit√©, etc.)_
  </script>

  <script type="text/markdown">
    ## <ins>Pr√©paration/nettoyage des donn√©es</ins>
  </script>

  <script type="text/markdown">
    Les donn√©es sont t√©l√©charg√©es et mises en forme dans un [script R](https://github.com/neocarto/missing-migrants/blob/main/data/build.R) qui g√©n√®re un fichier CSV unique. Ce script est disponible dans le dossier `data` du projet et est ex√©cut√© automatiquement au moment du build, pour produire des mises √† jour. Dans ce m√™me dossier, vous trouverez √©galement les fichiers de donn√©es brutes telles qu'elles ont √©t√© t√©l√©charg√©es et le fichier final `data.csv` qui est utilis√© pour la cartographie.
  </script>

  <script type="module" hidden>
    view(Inputs.table(all));
  </script>

  <script type="text/markdown">
    ## <ins>Une premi√®re visualisation</ins>
  </script>

  <script type="text/markdown">
    Les donn√©es incluent des coordonn√©es g√©ographiques, ce qui permet de cr√©er une premi√®re carte o√π le nombre de morts est repr√©sent√© par des cercles proportionnel.

    ‚ö†Ô∏è _Il y a **${all.length} cercles** sur la carte, ce qui peut poser des probl√®mes de lisibilit√©. Il y a beaucoup de superpositions. Beaucoup de cercles sont masqu√©s._
  </script>

  <script type="module" hidden>
    display(mapAll({ k: 100 }));
  </script>

  <script type="text/markdown">
    ## <ins>Agr√©gation</ins>
  </script>

  <script type="text/markdown">
    Pour r√©gler ce probl√®me, il est possible d'agr√©ger les cercles en fonction de leur localisation. Pour cela, nous utilisons l'algorithme de clustering [DBSCAN](https://www.npmjs.com/package/@turf/clusters-dbscan) (Density-Based Spatial Clustering of Applications with Noise), qui regroupe automatiquement des points en fonction de leur densit√© spatiale, sans avoir besoin de fixer √† l‚Äôavance le nombre de groupes. En faisant varier le param√®tre de distance (epsilon), le rayon dans lequel on cherche les voisins varie. Cela permet de produire des cartes plus ou moins agr√©g√©es.
  </script>

  <script type="module" hidden>
    const distance = view(
      Inputs.select([10, 20, 30, 40, 50, 100, 200], {
        label: "Distance",
        value: 50,
      }),
    );
  </script>

  <script type="text/markdown">
    Avec l'option `dodge` de la biblioth√®que `geoviz`, il est possible d'√©carter les cercles superpos√©s pour am√©liorer la lisibilit√©.
  </script>

  <script type="module" hidden>
    const dodge = view(
      Inputs.toggle({ label: "Ecarter les cercles", value: false }),
    );
  </script>

  <script type="module" hidden>
    display(mapAgregAll({ distance, dodge }));
  </script>

  <script type="text/markdown">
    ## <ins>Petits Multiples</ins>
  </script>

  <script type="text/markdown">
    Les deux cartes pr√©sent√©es ci-dessus couvrent l‚Äôensemble de la p√©riode, de 1993 √† aujourd‚Äôhui. Pour rendre compte de l‚Äô√©volution dans le temps, il est possible de d√©composer la carte par ann√©e et de cr√©er plusieurs petites cartes juxtapos√©es. C‚Äôest le principe des small multiples.
  </script>

  <script type="module" hidden>
    const nb = view(
      Inputs.radio([1, 2, 3, 4, 5], {
        label: "Nombre de cartes par ligne",
        value: 3,
      }),
    );
    const start = view(
      Inputs.select(
        Array.from({ length: 2026 - 1993 + 1 }, (_, i) => 1993 + i),
        { label: "Ann√©e de d√©part", value: 2018, format: (x) => x.toString() },
      ),
    );
  </script>

  <script type="module" hidden>
    display(smallMultiple(nb, start));
  </script>

  <script type="text/markdown">
    ## <ins>Carroyage</ins>
  </script>

  <script type="text/markdown">
    D‚Äôautres repr√©sentations sont possibles. La repr√©sentation en carroyage permet, par exemple, de visualiser les zones o√π le nombre de d√©c√®s est le plus √©lev√©.
  </script>

  <script type="module" hidden>
    const year = view(
      Inputs.select(
        Array.from({ length: 2026 - 1993 + 1 }, (_, i) => 1993 + i),
        { label: "Ann√©e", value: 2025, format: (x) => x.toString() },
      ),
    );

    const step = view(
      Inputs.radio([10, 15, 20, 25, 30, 35, 40, 45, 50], {
        label: "R√©solution",
        value: 30,
      }),
    );

    const type = view(
      Inputs.radio(["square", "hex", "diamond", "triangle", "arbitrary"], {
        label: "Type de carroyage",
        value: "square",
      }),
    );
  </script>

  <script type="module" hidden>
    display(grid({ type, step, year }));
  </script>

  <script type="text/markdown">
    ## <ins>La carte des morts de Migreurop</ins></ins>
  </script>

  <script type="text/markdown">
    La premi√®re _carte des morts_ a √©t√© con√ßue et produite par **Olivier Clochard** dans les ann√©es 2000-2002, et publi√©e en 2003 dans un num√©ro des Cahiers d‚ÄôOutre-Mer ([voir](https://journals.openedition.org/com/865?file=1)). Elle a ensuite √©t√© retravaill√©e et mise √† jour avec **Philippe Rekacewicz**, pour une publication dans le Monde Diplomatique en 2006 ([voir](https://www.monde-diplomatique.fr/cartes/mortsauxfrontieres?utm_source=chatgpt.com)). Puis, elle a √©t√© retravaill√©e et mise √† jour √† nouveau √† plusieurs reprises par le r√©seau **Migreurop** ([voir](https://neocarto.hypotheses.org/files/2017/03/carte_morts_classique.png)).

    Pour reproduire la carte de Migreurop, plusieurs √©tapes sont n√©cessaires :

    - S√©parer les donn√©es selon la cause du d√©c√®s (¬´ Noyade ¬ª, ¬´ Suicide ¬ª, ¬´ Asphyxie ¬ª, ¬´ Mort de faim, de soif, de froid ou d‚Äô√©puisement ¬ª, ¬´ Homicide, torture, absence de soin, violences polici√®res ¬ª, ¬´ Empoisonnement ¬ª, ¬´ Champ de mines, accident, autre ¬ª).
    - Effectuer une agr√©gation avec DBSCAN pour chaque cat√©gorie (distance = 100).
    - Assembler l‚Äôensemble des donn√©es dans un seul fichier.
    - Ajouter une l√©g√®re variation al√©atoire aux coordonn√©es.
    - R√©aliser la carte.
    - Finaliser l‚Äôhabillage et la mise en page (labels, couleurs, etc.).

    Et voil√† le r√©sultat üéâü•≥
  </script>

  <script type="module" hidden>
    let svg = viz.create({
      projection: "AzimuthalEqualArea.rotate([-20,-52])",
      domain: [
        [-25, 19],
        [42, 55],
      ],
      margin: 20,
      background: "#bde1f0",
      responsive: true,
    });
  </script>

  <script type="module" hidden>
    svg.graticule({ type: "graticule", id: "graticule", stroke: "white" });
    svg.plot({
      data: land,
      id: "countries",
      fill: "#E6DED4",
      strokeWidth: 0.3,
    });

    svg.plot({
      datum: eu,
      fill: "#E2BD93",
      id: "eu27",
      strokeWidth: 0.5,
      filter: svg.effect.shadow({
        stdDeviation: 2,
        fill: "black",
        fillOpacity: 0.2,
        dx: 2,
        dy: 2,
      }),
    });

    svg.plot({
      type: "proptypo",
      data: clusters,
      var1: "nb",
      var2: "type",
      colors: types.map((d) => d.color),
      k: 75,
      tip: (d) =>
        `${d.properties.type}\n ${d.properties.nb} personne${
          d.properties.nb > 1 ? "s" : ""
        }`,
      stroke: "white",
      strokeWidth: 0.2,
      leg2_rect_width: 15,
      leg2_rect_height: 15,
      leg2_pos: [25, 215],
      leg2_title: "Cause de la mort",
      leg2_values_stroke: "#bde1f0",
      leg2_values_strokeWidth: 14,
      leg2_values_dx: 8,
      leg2_values_paintOrder: "stroke",
      leg2_values_strokeLinejoin: "round",
      leg1_pos: [20, 20],
      leg1_values_round: 0,
      leg1_title: "Nombre de morts",
      leg1_subtitle: `Du 1er janvier 1993 au ${formatDateFR(date)}`,
      leg1_title_dy: -5,
    });

    svg.path({
      datum: schengen,
      id: "schengen",
      stroke: "#383333",
      strokeDasharray: [5, 3],
      strokeOpacity: 0.5,
      strokeWidth: 1.4,
      filter: svg.effect.shadow({
        stdDeviation: 1,
        fill: "black",
        fillOpacity: 0.5,
        dx: 1,
        dy: 1,
      }),
    });
    svg.scalebar({
      id: "scale",
      units: "km",
      label: "Kilom√®tres",
    });
    svg.header({
      text: "Des morts par milliers aux portes de l'Europe",
      id: "header",
      background_fill: "#454545",
      fill: "white",
    });
    toponymes.forEach((d) => {
      svg.text({
        id: d.id,
        pointerEvents: "none",
        coords: "geo",
        pos: [d.pos[1], d.pos[0]],
        text: d.fr,
        textAnchor: d.anchor,
        fill: d.fill || "#454545",
        fillOpacity: d.fillOpacity || 1,
        fontWeight: "bold",
        strokeWidth: d.strokeWidth,
        strokeOpacity: d.strokeOpacity || 0.7,
        fontSize: d.fontSize,
        stroke: d.stroke || "white",
      });
    });
    svg.text({
      pos: [866, 15],
      textAnchor: "middle",
      fontSize: 50,
      fill: "#454545",
      fontWeight: "bold",
      text: `${d3
        .format(",.2r")(d3.sum(data.map((d) => d.nb)))
        .replace(",", " ")}`,
      id: "total",
    });

    svg.text({
      pos: [866, 65],
      textAnchor: "middle",
      fontSize: 14,
      fill: "#454545",
      stroke: "#E6DED4",
      strokeWidth: 4,
      text: `C'est le nombre de personnes\nmigrantes mortes ou port√©es\ndisparues en essayant de\nrejoindre l'Union europ√©enne\nentre ${yearmin} et ${yearmax}.\n\nDit autrement, ce sont\n${nbbyweek} femmes, hommes\net enfants qui perdent\nla vie chaque semaine.`,
    });

    svg.text({
      text: source,
      pos: [svg.width - 15, 450],
      textAnchor: "end",
      fontSize: 10,
      fill: "#76858C",
      fillOpacity: 0.7,
      fontStyle: "italic",
      textDominantBaseline: "hanging",
      id: "source",
    });
    display(svg.render());
  </script>

  <script type="module">
    const button_svg = Inputs.button("T√©l√©charger en svg");
    const button_png = Inputs.button("T√©l√©charger en png");
    const container = document.createElement("div");
    container.className = "button-container"; // <-- ici la classe
    container.append(button_svg);
    container.append(button_png);
    display(container);
    button_svg.addEventListener("click", () => {
      viz.exportSVG(d3.select(svg.node()));
    });
    button_png.addEventListener("click", () => {
      viz.exportPNG(d3.select(svg.node()));
    });
  </script>

  <script type="text/markdown">
    ## <ins>Licence</ins>

    Distribu√© sous licence GNU GPL v3.0  
    https://www.gnu.org/licenses/gpl-3.0.html
  </script>

  ********** APPENDIX ************

  <script type="text/x-r" hidden>
    source("../data/build.R")
  </script>

  <script type="text/markdown">
    <link rel="stylesheet" href="./style.css" />
  </script>

  LIBRARIES & HELPERS

  <script id="imports" type="module" hidden>
    import { formatDateFR } from "./helpers/formatDateFR.js";
    import { toGeoJSON } from "./helpers/toGeoJSON.js";
    import { clustering } from "./helpers/clustering.js";
    import { clustersDbscan } from "@turf/clusters-dbscan";
    const viz = import("geoviz");
  </script>

  PARAMS

  <script id="imports" type="module" hidden>
    const yearmin = 1993;
    const yearmax = new Date().getFullYear();
    const lang = "fr"; // "en" or "fr"
  </script>

  DATA LOADING

  <script type="module" hidden>
    let all = await FileAttachment("../data/data.csv").csv();
    let land = await FileAttachment("../data/land.json").json();
    let eu = await FileAttachment("../data/eu.json").json();
    let schengen = await FileAttachment("../data/schengen.json").json();
    let toponymes = await FileAttachment("../data/toponymes.json").json();
    let date = FileAttachment("../data/last_update.txt").text();
  </script>

  CATEGORIES & COLORS

  <script type="module" hidden>
    let types = [
      { type: "Noyade", color: "#58ABD3" },
      { type: "Suicide", color: "#F8E91F" },
      { type: "Asphyxie", color: "#6B2265" },
      {
        type: "Mort de faim, de soif, de froid ou d'√©puisement",
        color: "#1C7532",
      },
      {
        type: "Homicide, torture, absence de soin, violences polici√®res",
        color: "#F49919",
      },
      {
        type: "Empoisonnement, Champ de mine, accident, autre",
        color: "#637A84",
      },
    ];
  </script>

  SVG CONTAINER FILTER

  <script type="module" hidden>
    const check = new Map(
      viz.tool
        .project(viz.tool.featurecollection(all, { lat: "lat", lon: "lng" }), {
          projection: svg.projection,
        })
        .features.map((d) => [d.properties.id, d.geometry?.coordinates]),
    );
  </script>

  <script type="module" hidden>
    let data = all.filter((d) => Array.isArray(check.get(d.id)));
  </script>

  CLUSTERING

  <script type="module" hidden>
    let categories = types.map((d) => d.type);
    let features = [];
    categories.forEach((categ) => {
      let mycateg = data.filter((d) => d.fr == categ);
      features.push(clustering(toGeoJSON(mycateg), 20, categ).features);
    });
    let clusters = { type: "FeatureCollection", features: features.flat() };
  </script>

  SOME TEXTS TO DISPLAY

  <script type="module" hidden>
    let source1 = "UNITED for Intercultural\nAction (1993-1999)";
    let source2 = `The "Migrants Files" project\n(2000 - 2013)`;
    let source3 =
      lang == "en"
        ? "International Organization\nfor Migration\n(2014 to now)"
        : "Organisation Internationale\npour les Migrations\n(2014 √† aujourd'hui)";

    let source =
      lang == "en"
        ? "Map design\nNicolas Lambert, 2026"
        : "Cartographie\nNicolas Lambert, 2026\n";

    if (yearmin < 2000) {
      source += "\n" + source1;
    }
    if (yearmin <= 2013 && yearmax >= 2000) {
      source += "\n" + source2;
    }
    if (yearmax >= 2014) {
      source += "\n" + source3;
    }
  </script>

  <script type="module" hidden>
    let update = new Date(date);
    let Difference_In_Time =
      update.getTime() - new Date(`${yearmin}-01-01`).getTime();
    const days = Math.round(Difference_In_Time / (1000 * 3600 * 24));
    const weeks = days / 7;
    const nbbyweek = Math.round(d3.sum(data.map((d) => d.nb)) / weeks);
  </script>

  SMALL MULTIPLE

  <script type="module">
    function mapByYear({
      year = 2020,
      distance = 300,
      parent,
      width = 1000,
      pos = [0, 0],
      k = 70,
    } = {}) {
      const clusters = clustering(
        viz.tool.featurecollection(
          data.filter((d) => d.year == year),
          { lat: "lat", lon: "lng" },
        ),
        distance,
      );

      let svg = viz.create({
        parent: parent,
        projection: d3.geoAzimuthalEqualArea().rotate([-20.0, -52.0]),
        width,
        pos,
        domain: [
          [-25, 19],
          [42, 55],
        ],
      });
      svg.plot({ type: "outline" });
      svg.plot({
        datum: land,
        fill: "white",
      });
      svg.plot({
        data: schengen,
        stroke: "#383333",
        strokeDasharray: [5, 3],
        strokeOpacity: 0.5,
        strokeWidth: 1,
        filter: svg.effect.shadow({
          stdDeviation: 1,
          fill: "black",
          fillOpacity: 0.5,
          dx: 1,
          dy: 1,
        }),
      });
      svg.plot({
        type: "prop",
        data: clusters,
        var: "nb",
        k,
        fixmax: 1000,
        fill: "#E94849",
        fillOpacity: 0.8,
        tip: "$nb",
        legend: false,
      });
      svg.plot({
        type: "text",
        pos: [10, 10],
        text: `${year}`,
        fontSize: 30,
        fontWeight: "bold",
        fill: "white",
      });
      svg.plot({
        type: "text",
        pos: [10, 40],
        text: `${d3.sum(clusters.features.map((d) => d.properties.nb))} mort.e.s`,
        fontSize: 12,
        fontWeight: "bold",
        fill: "#474746",
      });

      return svg.render();
    }
  </script>

  <script type="module">
    function smallMultiple(perRow = 3, start = 1993) {
      const years = [...new Set(data.map((d) => +d.year))]
        .sort()
        .filter((d) => d >= start);

      const width = 1000;

      const cardWidth = width / perRow;
      const cardHeight = cardWidth / 1.46;

      let main = viz.create({
        responsive: true,
        width,
        height: Math.ceil(years.length / perRow) * cardHeight,
      });

      years.forEach((year, i) => {
        const row = Math.floor(i / perRow);
        const col = i % perRow;

        const x = col * cardWidth;
        const y = row * cardHeight;

        mapByYear({
          year,
          parent: main,
          width: cardWidth,
          k: 20,
          pos: [x, y],
        });
      });

      return main.render();
    }
  </script>

  <script type="module">
    function mapAll({ k = 50 } = {}) {
      let svg = viz.create({
        projection: d3.geoAzimuthalEqualArea().rotate([-20.0, -52.0]),
        width,
        responsive: true,
        domain: [
          [-25, 19],
          [42, 55],
        ],
      });
      svg.plot({ type: "outline" });
      svg.plot({
        datum: land,
        fill: "white",
      });
      svg.plot({
        data: schengen,
        stroke: "#383333",
        strokeDasharray: [5, 3],
        strokeOpacity: 0.5,
        strokeWidth: 1,
        filter: svg.effect.shadow({
          stdDeviation: 1,
          fill: "black",
          fillOpacity: 0.5,
          dx: 1,
          dy: 1,
        }),
      });
      svg.plot({
        type: "prop",
        data: clusters,
        var: "nb",
        k,
        fill: "#E94849",
        fillOpacity: 0.8,
        tip: "$nb",
        leg_title:
          "Personnes mortes\nou port√©es disparues\nde 1993 √† aujourd'hui",
        leg_subtitle: "(Nombre de personnes)",
        leg_values_round: 0,
      });

      return svg.render();
    }
  </script>

  <script type="module" hidden>
    function mapAgregAll({
      distance = 50,
      width = 1000,
      k = 100,
      fixmax = 30000,
      dodge = false,
    } = {}) {
      const clusters = clustering(
        viz.tool.featurecollection(data, { lat: "lat", lon: "lng" }),
        distance,
      );

      let svg = viz.create({
        projection: d3.geoAzimuthalEqualArea().rotate([-20.0, -52.0]),
        width,
        responsive: true,
        domain: [
          [-25, 19],
          [42, 55],
        ],
      });
      svg.plot({ type: "outline" });
      svg.plot({
        datum: land,
        fill: "white",
      });
      svg.plot({
        data: schengen,
        stroke: "#383333",
        strokeDasharray: [5, 3],
        strokeOpacity: 0.5,
        strokeWidth: 1,
        filter: svg.effect.shadow({
          stdDeviation: 1,
          fill: "black",
          fillOpacity: 0.5,
          dx: 1,
          dy: 1,
        }),
      });
      svg.plot({
        type: "prop",
        data: clusters,
        var: "nb",
        k,
        fixmax,
        dodge,
        fill: "#E94849",
        fillOpacity: 0.8,
        tip: "$nb",
        leg_title:
          "Personnes mortes\nou port√©es disparues\nde 1993 √† aujourd'hui",
        leg_subtitle: "(Nombre de personnes)",
        leg_values_round: 0,
      });

      return svg.render();
    }
  </script>

  <script type="module">
    function grid({ type = "square", step = 10, year = "2025" } = {}) {
      let svg = viz.create({
        projection: d3.geoAzimuthalEqualArea().rotate([-20.0, -52.0]),
        width,
        responsive: true,
        domain: [
          [-25, 19],
          [42, 55],
        ],
      });

      let grid = svg.grid({
        type: type,
        step: step,
        data: viz.tool.featurecollection(
          all.filter((d) => d.year == year),
          { lat: "lat", lon: "lng" },
        ),
        var: "nb",
      });
      const maxVal = d3.max(grid.features.map((d) => d.properties.nb));
      const breaks = [1, 5, 10, 25, 50, 100, 500, 1000, maxVal].filter(
        (b) => b <= maxVal,
      );
      const colors = [
        "#ffffcc",
        "#ffeda0",
        "#fed976",
        "#feb24c",
        "#fd8d3c",
        "#fc4e2a",
        "#e31a1c",
        "#b10026",
      ].slice(0, breaks.length - 1);
      svg.plot({ type: "outline" });
      svg.plot({
        datum: land,
        fill: "white",
      });

      svg.plot({
        type: "choro",
        coords: "svg",
        colors,
        data: grid,
        var: "nb",
        tip: "$nb",
        fillOpacity: 0.8,
        breaks,
        leg_title: `Nombre de personnes\nmortes ou port√©es\ndisparues en ${year}`,
      });
      svg.plot({
        data: schengen,
        stroke: "#383333",
        strokeDasharray: [5, 3],
        strokeOpacity: 0.5,
        strokeWidth: 1,
        filter: svg.effect.shadow({
          stdDeviation: 1,
          fill: "black",
          fillOpacity: 0.5,
          dx: 1,
          dy: 1,
        }),
      });

      return svg.render();
    }
  </script>
</notebook>
