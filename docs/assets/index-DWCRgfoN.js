var a=63710088e-1,m={centimeters:a*100,centimetres:a*100,degrees:360/(2*Math.PI),feet:a*3.28084,inches:a*39.37,kilometers:a/1e3,kilometres:a/1e3,meters:a,metres:a,miles:a/1609.344,millimeters:a*1e3,millimetres:a*1e3,nauticalmiles:a/1852,radians:1,yards:a*1.0936};function s(r,e,t={}){const n={type:"Feature"};return(t.id===0||t.id)&&(n.id=t.id),t.bbox&&(n.bbox=t.bbox),n.properties=e||{},n.geometry=r,n}function A(r,e,t={}){if(!r)throw new Error("coordinates is required");if(!Array.isArray(r))throw new Error("coordinates must be an Array");if(r.length<2)throw new Error("coordinates must be at least 2 numbers long");if(!f(r[0])||!f(r[1]))throw new Error("coordinates must contain numbers");return s({type:"Point",coordinates:r},e,t)}function M(r,e,t={}){for(const i of r){if(i.length<4)throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");if(i[i.length-1].length!==i[0].length)throw new Error("First and last Position are not equivalent.");for(let o=0;o<i[i.length-1].length;o++)if(i[i.length-1][o]!==i[0][o])throw new Error("First and last Position are not equivalent.")}return s({type:"Polygon",coordinates:r},e,t)}function P(r,e,t={}){if(r.length<2)throw new Error("coordinates must be an array of two or more positions");return s({type:"LineString",coordinates:r},e,t)}function v(r,e={}){const t={type:"FeatureCollection"};return e.id&&(t.id=e.id),e.bbox&&(t.bbox=e.bbox),t.features=r,t}function E(r,e,t={}){return s({type:"MultiLineString",coordinates:r},e,t)}function p(r,e,t={}){return s({type:"MultiPolygon",coordinates:r},e,t)}function w(r,e="kilometers"){const t=m[e];if(!t)throw new Error(e+" units is invalid");return r*t}function d(r,e="kilometers"){const t=m[e];if(!t)throw new Error(e+" units is invalid");return r/t}function x(r,e){return b(d(r,e))}function b(r){return r%(2*Math.PI)*180/Math.PI}function u(r){return r%360*Math.PI/180}function f(r){return!isNaN(r)&&r!==null&&!Array.isArray(r)}function L(r){return r!==null&&typeof r=="object"&&!Array.isArray(r)}function g(r){if(!r)throw new Error("coord is required");if(!Array.isArray(r)){if(r.type==="Feature"&&r.geometry!==null&&r.geometry.type==="Point")return[...r.geometry.coordinates];if(r.type==="Point")return[...r.coordinates]}if(Array.isArray(r)&&r.length>=2&&!Array.isArray(r[0])&&!Array.isArray(r[1]))return[...r];throw new Error("coord must be GeoJSON Point or an Array of numbers")}function q(r,e,t={}){var n=g(r),i=g(e),o=u(i[1]-n[1]),h=u(i[0]-n[0]),c=u(n[1]),y=u(i[1]),l=Math.pow(Math.sin(o/2),2)+Math.pow(Math.sin(h/2),2)*Math.cos(c)*Math.cos(y);return w(2*Math.atan2(Math.sqrt(l),Math.sqrt(1-l)),t.units)}export{u as a,s as b,P as c,q as d,M as e,v as f,p as g,a as h,L as i,x as l,E as m,A as p,b as r};
